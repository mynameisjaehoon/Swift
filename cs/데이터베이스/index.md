# 인덱스(Index)
## 인덱스란?
추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조이다. 책에서 원하는 내용을 찾고자 할때 책의 모든페이지를 뒤지면 오랜 시간이 걸린다. 그래서 책의 목차(색인)을 참고하는데 데이터베이스의 index가 이 목차(색인)에 해당한다.

데이터베이스에서도 동일하게 원하는 데이터를 찾고자 할 때 전체 데이터베이스를 뒤지지 않고 데이터와 데이터의 위치를 포함한 자료구조를 생성하여 빠르게 조회할 수 있도록 돕고있다. 

인덱스를 사용하게 되면 데이터를 조회하는 `SELECT` 연산 외에도 `UPDATE`나 `DELETE`의 성능이 향상된다. `UPDATE`나 `DELETE`도 조회를 거쳐야만 작업을 처리할 수 있기 때문이다.

## 인덱스의 관리
DBMS는 index를 항상 정렬된 상태로 유지하므로, 빠른 속도로 탐색할 수 있지만 정렬된 상태를 유지해야하므로 거기서 발생하는 오버헤드가 존재하다. `INSERT`, `DELETE`, `UPDATE`연산시에는 다음과 같은 추가적인 작업이 필요하다.
- **`INSERT`** : 새로운 데이터에 대한 인덱스를 추가해야한다.
- **`DELETE`** : 기존에 사용하던 인덱스를 사용하지 않는다는 표시를 한다.
- **`UPDATE`** : UPDATE의 경우에는 이전의 데이터가 삭제되고 그 자리에 새로운 데이터가 들어오는 개념이기 때문에 INSERT와 DELETE의 추가적인 작업이 모두 필요하다.

## 인덱스의 장점과 단점
### 장점
1. **조건검색 WHERE절의 효율성**<br>
    테이블을 만든후, 데이터가쌓이면 내부의 데이터는 순서가 없이 뒤죽박죽으로 쌓이게 된다. 이 상태에서 데이터를 찾아내기 위해서는 레코드를 처음부터 끝까지 읽어서 검색조건과 맞는지 비교해야한다. 이것을 **풀 테이블 스캔(Full Table Scan)** 이라고 한다. 하지만 **인덱스 테이블 스캔(Index Table Scan)** 을 함으로서 인덱스는 정렬되어있기 때문에 조건에 맞는 데이터들을 빠르게 찾아낼 수 있다.
2. **정렬 ORDER BY절의 효율성**<br>
    인덱스가 정렬되어있기 때문에 `ORDER BY`에 의한 정렬과정을 피할 수 있다. 정렬은 동시에 1차적으로 메모리에서 정렬이 이루어지고, 메모리보다 큰 작업이 필요하다면 디스크 IO까지 필요해지는 부하가 많이 걸리는 작업이기 때문이다. 인덱스를 사용하면 정렬이 미리되어있기 때문에 데이터를 가져오기만 하면 된다.
3. **MIN, MAX의 효율적인 처리가 가능하다.**<br>
    인덱스를 사용하면 데이터가 미리 정렬되어 있기 때문에 최솟값과 최댓값을 가져오기 위해서는 시작 값과 끝 값 한건씩만 가져오면 되기 때문에 `Full Table Scan`으로 테이블을 모두 뒤져서 작업하는 것보다 훨씬 효율적으로 찾을 수 있다.
### 단점
1. **인덱스는 DML에 취약하다.**<br>
    인덱스는 정렬되어있는 자료구조이기 때문에, `INSERT`, `DELETE`, `UPDATE`를 통해서 데이터를 추가하거나, 수정하였을때 인덱스 테이블 내의 값을 다시 정렬해야한다. 따라서 원래는 하나의 원본테이블만 정렬하면 되었지만, 인덱스를 사용함으로써 인덱스 테이블과 원본테이블 두군데의 데이터 수정작업을 해주어야 한다는 단점이 있다.
2. **인덱스 스캔이 무조건 좋은것은 아니다.**<br>
    인덱스는 테이블의 전체 데이터 중에서 10~15%이하의 데이터를 처리하는 경우에만 효율적이고 그 이상의 데이터를 처리할 땐 인덱스를 사용하지 않는 것이 좋다. 
3. **인덱스를 위한 추가적인 저장공간이 필요하다.**<br>
    인덱스를 만들기 위해서는 약 10%정도의 저장공간이 더 필요하기 때문에 속도 향상과 더 쓰여지는 저장공간의 COST를 비교해서 인덱스를 만들지 말지 결정해야한다.

`CREATE`, `DELETE`, `UPDATE가` 빈번한 속성에 인덱스를 걸게되면 **인덱스의 크기가 필요이상으로 비대해져 낭비되는 공간이 생길 수 있다.** 위에서 `DELETE`시에 기존에 사용되던 인덱스를 삭제하는 것이 아니라 인덱스를 사용하지 않는다는 표시만 한다고 하였다. 이러한 과정이 쌓이다보면 실제로 사용하는 데이터의 수보다 인덱스의 개수가 비대해질 수 있다는 것이다.

따라서 인덱스를 사용하는 것도 중요하지만 그만큼 사용하지 않는 인덱스를 삭제해주는 것도 중요하다.

> **면접때 받았던 질문**<br>
> 그럼 이런 문제를 어떻게 해결할 수 있나요?

### 인덱스를 사용하면 좋은 경우
- 규모가 작지 않은 테이블 
- INSERT, DELETE, UPDATE가 자주 발생하지 않는 컬럼
- JOIN, WHERE 또는 ORDER BY에 자주 사용되지 않는 컬럼
- 데이터의 중복도가 낮은 컬럼

## 인덱스의 자료구조
인덱스의 자료구조로는 여러가지가 사용될 수 있지만 대표적으로 해시테이블과 B+Tree가 있다.
### 해시테이블(Hash Table)
해시테이블은 잘 알다시피 키와 값의 쌍으로 데이터를 저장하는 자료구조로, 빠른데이터의 검색이 필요할 때 유용하다. 시간복잡도도 **`O(1)`** 이기 때문에 매우 빠른검색을 지원한다. 하지만 잘 쓰이지는 않는데 그 이유는 해시테이블은 동등(=)연산에만 특화되어 있기 때문이다. 쿼리에는 부등호 연산(>,<)도 자주 사용되기 때문에 해시테이블이 적합하지 않ㄴ다.
### B+Tree
B+Tree는 DB의 인덱스를 위해 자식노드가 2개 이상인 B-Tree를 개선시킨 자료구조이다.
- 리프노드만 인덱스와 함께 데이터를 가지고 있고, 나머지 노드들은 데이트를 위한 인덱스만을 갖는다.
- 리프노드들은 연결리스트로 연결되어있다.
- 데이터 노드의 크기는 인덱스 노드의 크기와 같지 않아도 된다.

데이터베이스의 인덱스 컬럼은 부등호를 이용한 순차검색연산이 자주 발생할 수 있다. 이러한 이유로 B-Tree의 리프노드들을 연결리스트로 연결하여 순차검색에 용이하게 하는 등 B-Tree를 인덱스에 맞게 최적화한 것이다. **`O(logn)`** 의 시간복잡도를 가져 해시테이블 보다는 느리지만 인덱싱에 더욱 적합한 자료구조이다.

# Question
> **인덱스가 무엇이고, 언제사용하는지 설명해주세요**<br>
> 인덱스란 데이터베이스의 탐색을 빠르게 하기 위해서 컬럼값과 레코드의 주소를 키, 값 쌍으로 하는 자료구조입니다.

> **일반적으로 인덱스는 수정이 잦은 테이블에선 사용하지 않기를 권합니다. 왜 그럴까요?**<br>
> 인덱스는 기본적으로 정렬된 상태를 유지해야하기 때문에 데이터에 수정이 일어나면 인덱스의 정렬을 위해 작업이 필요하게 됩니다. 수정이라고 하면 삽입, 삭제, 수정작업이 있는데 삽입작업의 경우에는 새로운 인덱스를 생성해야하고 삭제작업은 인덱스를 삭제하는 것이 아니라 사용하지 않는다는 표시만 해두기 때문에 실제로 사용하는 데이터에 비해서 인덱스테이블의 사이즈가 비대해질 수 있습니다. 수정의 경우에는 기존에 존재하던 데이터를 삭제하고 새로운 데이터를 삽입하는 방식으로 구현되어 있기 때문에 앞에서 말씀드린 삽입과 삭제의 단점이 모두 나타나게 됩니다.

> **B-Tree와 B+Tree에 대해 설명해주세요.**<br>
> B-Tree는 탐색 성능을 높이기 위해 균형있게 높이를 유지하는 밸런스 트리의 일종입니다. 모든 리프노드가 같은 레벨로 유지되도록 자동으로 밸런스를 맞춰줍니다. B+Tree는 B-Tree의 확장개념으로, B+Tree의 경우 브랜치노드에 키만 담아두고 노드는 담지 않습니다. 오직 리프노드에만 키와 데이터를 저장하고 리프노드끼리는 연결리스트로 연결되어 있습니다.

> **그렇다면 B+Tree는 항상 B-Tree보다 좋다고 할 수 있을까요? 그렇지 않다면 어떤 단점이 있을까요?**<br>
> 특수한 경우에는 탐색속도가 B-Tree보다 좋지 않다고 할 수 있습니다. 예를 들어 찾고자 하는데이터가 트리의 루트에 있을 경우에 B-Tree는 바로 탐색을 종료하면되지만 B+Tree는 일단 리프노드까지는 가야하기 때문입니다. 그리고 B-Tree와는 다르게 키값이 중복될 수 있습니다. 

> **DB에서 RBT를 사용하지 않고 B-Tree/B+Tree를 사용하는 이유가 있을까요?**<br>
> 흠...그러게요

> **Table Full Scan, Index Range Scan에 대해 설명해주세요.**<br>
> 전체 테이블 스캔(Full Table Scan)은 테이블에 존재하는 모든 데이터를 읽어 가면서 조건에 맞으면 결과로서 추출하고 조건에 맞지 않으면 버리는 방식이다. 일반적으로 블록이 인접해 있기 때문에 한번의 I/O로 여러 블록을 옮겨온다. 따라서 Row당 소요되는 입출력 비용이 인덱스 스캔에 비해 적다. 하지만 테이블의 모든 데이터를 읽으면서 원하는 데이터를 찾아야 하기 때문에 비효율적인 검색을 하게 됩니다. 그러나 테이블의 대부분의 데이터를 찾을 때는 한 블록씩 읽는 인덱스 스캔 방식보다는 어차피 대부분의 데이터를 읽을 거라면 한번에 여러 블록씩 읽는 전체 테이블 스캔 방식이 유리할 수 있습니다. 결과를 찾기 위해서 모든 블럭을 읽은 것이므로 읽은 블록들의 재사용성이 떨어진다. 따라서 전체 테이블 스캔 방식으로 읽은 블록들은 메모리에서 곧 제거될 수 있도록 관리됩니다.<br><br>
> 인덱스를 구성하는 컬럼의 값을 기반으로 데이터를 추출하는 액세스 기법입니다. 대용량의 데이터중에서 일부의 데이터를 찾을때 인덱스 스캔 방식을 사용해 몇번의 I/O만으로 원하는 데이터를 쉽게 찾을 수 있습니다.


# Reference
- [인덱스(Index)란?](https://mangkyu.tistory.com/96)
- [데이터베이스 인덱스](https://choicode.tistory.com/27)
- [간단히 알아보는 B-Tree, B+Tree, B*Tree](https://ssocoit.tistory.com/217)
- [인덱스 스캔과 전체 테이블 스캔](https://hoon93.tistory.com/53)