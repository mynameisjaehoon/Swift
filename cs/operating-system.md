# 운영체제

- [시스템 콜](#시스템-콜)
    - [시스템 콜의 실행과정](#시스템콜의-실행-과정)
    - [시스템 콜의 유형](#시스템-콜의-유형)
- [이중동작모드](#운영체제의-이중동작모드dual-mode)
    - [이중동작모드(Dual-Mode)란?](#dual-mode란)
- [프로세스와 스레드](#프로세스와-스레드)
    - [프로그램이란?](#프로그램program이란)
    - [프로세스란?](#프로세스process란)
    - [스레드란?](#스레드란)
- [멀티스레드? 멀티프로세스? 장단점](#멀티-프로세스보다-멀티-스레드)
- [스케줄러](#스케줄러)
    - [장기 스케줄러](#장기-스케줄러)
    - [단기 스케줄러](#단기-스케줄러)
    - [중기 스케줄러](#중기-스케줄러)
- [CPU 스케줄러](#cpu-스케줄러)
    - [FCFS(First Come First Serve)](#fcfsfirst-come-first-serve)
    - [SJF(Shortest-Job-First)](#sjfshortest-job-first)
    - [SRTF(Shortest Remaing Time First)](#srtfshortest-remaing-time-first)
    - [Priority-Scheduling](#priority-scheduling)
    - [Round-Robin](#round-robin-정보처리기사-시험에서-갑자기-기억이-나지-않아서-쓰지-못했던)
- [프로세스 동기화](#프로세스-동기화)
    - [Critical Section Problem](#critical-section)
    - [Critical Section - 임계영역 문제](#critical-section-problem임계-영역문제)
    - [Mutex Lock](#mutex-lock)
    - [Semaphore](#semaphore세마포어)
    - [Deadlock 데드락](#deadlock교착상태)
- [메모리 관리 전략](#메모리-관리-전략)
    - [메모리를 왜 관리해?](#메모리를-왜-관리해)
    - [Swapping](#swapping)
    - [단편화(Fragmentation)](#단편화fragmentation)
    - [Paging(페이징)](#paging페이징)
    - [Segmentation(세그멘테이션)](#segmentation세그멘테이션)
- [가상메모리](#가상메모리)
    - [개발배경](#개발-배경)
    - [가상메모리가 하는 일?](#가상메모리가-하는-일)
    - [Demand Paging(요구 페이징)](#demand-paging요구-페이징)
    - [페이지 교체](#페이지-교체)

---

## 시스템 콜
- 시스템콜은 운영체제에서 제공하는 서비스를 이용하기 위한 프로그래밍 인터페이스이다.
- 시스템 콜의 유형으로는 프로세스 제어, 파일조작, 장치조작, 정보 유지보수, 통신과 보호 등으로 나눌 수 있다.
- 사용자 모드에서는 애플리케이션 코드가 사용되고, 접근할 수 있는 영역에 제한이 있기 때문에 해당 모드에서는 하드웨어(디스크, I/O등)에 직접적으로 접근할 수 없습니다. 접근을 위해서 시스템 콜을 사용하게 됩니다.
- 사용되는 시스템 콜의 예시는 다음이 있습니다.
    - fork(): 자식 프로세스 생성
    - exec(): 자신을 수행가능한 다른 프로세스로 대치
    - wait(): 프로세스 종료시까지 대기
    - 이 외에도 pipe, signal, exit, open, create, close, read, write등이 있다.


### 시스템콜의 실행 과정

<img width="70%" src="https://user-images.githubusercontent.com/76734067/212707431-a854e8df-61a1-41cf-90cb-335dbc190c3b.png">

1. 라이브러리 함수(예: printf)를 호출한다.
2. 라이브러리 함수 내부에서 시스템 콜(write)를 호출한다.
3. 시스템 콜의 인덱스를 CPU레지스터에 저장한다.
4. 0x80 인터럽트를 발생시킨다.(커널모드로 전환)
5. IDT(Interrupt Descriptor Table)을 참조하여 system_call()을 호출한다.
6. 이때 `3`에서 저장한 인덱스를 system_call()함수 내에 저장한다.
7. sys_call_table을 참조해 해당 인덱스에 맞는 기능(sys_write)을 호출한다.
8. 수행이 모두 끝나면 사용자 모드로 전환한다.

### 시스템 콜의 유형
시스템콜은 위에서도 설명했듯이 다음 6가지 유형이 있다.
- 프로세스 제어
- 파일 조작
- 디바이스 조작
- 정보관리
- 커뮤니케이션
- 보안

## 운영체제의 이중동작모드(Dual-Mode)

### Dual-Mode란?
  이중 동작 모드(Dual-mode Operation)이란 운영체제를 보호하기 위한 기법입니다. 사용자와 운영체제는 시스템 자원을 공유하기 때문에 사용자에게 제한을 주지 않으면 사용자가 메모리 내의 주요 운영체제 자원을 망가뜨릴 위험이 생기게 됩니다. 따라서 시스템 자원 접근을 제한하는 보호장치가 필수적인데 그를 위해서 이중 동작모드를 사용하게 됩니다. **커널 모드**와 **유저 모드**라는 두가지 모드로 나뉘게 됩니다.
  - 커널모드
    - supervisor mode, system mode, privileged mode등으로도 불리운다.
    - 운영체제를 위한 동작을 담당한다.
    - 시스템의 **모든 메모리에 접근**할 수 있고 **모든 CPU명령을 실행**할 수 있다.
    - 운영체제 코드나 디바이스 드라이버 같은 커널모드 코드를 실행한다.
    - CPU는 커널모드 특권 수준에서 코드를 실행한다.
  - 유저모드
    - 사용자를 위한 동작을 담당한다.
    - 사용자 애플리케이션 코드가 실행된다.
    - 시스템 데이터에 **제한된 접근만이 허용**되며 하드웨어를 직접 접근할 수 없다.
    - 유저 애플리케이션에서 시스템 서비스를 호출하면 유저모드에서 커널모드로 전환된다.
    - 유저모드에서 실행하는 스레드는 자신만의 유저모드 스택을 가진다.

> **서로 다른 시스템 콜을 어떻게 구분할 수 있을까요?**<br>
  커널은 내부적으로 각각의 시스템 콜을 구분하기 위해 기능별로 고유번호를 할당하고 그 번호에 해당하는 제어루틴을 커널 내부에 정의하고 있습니다.

## 프로세스와 스레드

### 프로그램(Program)이란?
- 사전적의미로는 어떤 작업을 위해 실행할 수 있는 파일

### 프로세스(Process)란?
- 사전적의미로는, 컴퓨터에서 연속적으로 실행되고 있는 프로그램
    - **메모리에 올라와서 실행**되고 있는 프로그램의 인스턴스
    - 운영체제로부터 시스템 자원을 할당받는 작업의 단위
    - 동적인 개념에서는 실행중인 프로그램을 의미한다.
- 할당받는 시스템자원에는 무엇이 있나?
    - CPU 시간
    - 운영되기 위해서 필요한 메모리 공간
    - Code, Data, Stack, Heap 구조로 되어있는 독립된 **메모리영역**
- 특징
    - 프로세스는 각각 **독립된 메모리 영역**(Code, Data, Stack, Heap)을 할당받는다.
    - 프로세스당 최소 1개의 스레드(메인스레드)를 가지고 있다.
    - 각 프로세스는 별도의 주소공간에서 실행된다. 다른 프로세스의 데이터에 접근할 수 없다.
    - 다른 프로세스의 자원에 접근하려면 프로세스간 통신(IPC, Inter-Process Communication)을 사용해야한다. 

### 스레드란?
- 프로세스가 할당받은 자원을 이용하는 실행의 단위
- 특징
    - 스레드는 프로세스 영역에서 Stack만 따로 할당받고, Code, Data, Heap영역은 공유한다.
    - 스레드는 한 프로세스 내에서 실행되는 **여러**실행의 흐름으로, 프로세스 내의 주소공간이나 자원들을 같은 프로세스 내의 스레드끼리 공유하면서 실행할 수 있다.
    - 같은 프로세스 안에 있는 스레드들은 힙영역을 공유한다. IPC를 사용하지 않는 이상 프로세스는 다른 프로세스의 자원에 접근할 수 없다는 점을 기억하자.
    - 레지스터와 스택은 별도의 영역을 가진다.
    - 한 프로세스가 프로세스 자원을 변경하면 다른 스레드도 변경된 내용을 읽을 수 있다.
        - 하지만 이 때문에 자원의 동기화문제를 고려해야한다는 단점이 있다.
    
[처음으로](#운영체제)

## 멀티 프로세스보다 멀티 스레드!
멀티 프로세스는 프로그램을 여러개 켜는 것이고, 멀티 스레드는 하나의 프로그램에서 여러 작업을 해결하는 것이다.<br>
멀티 스레드의 장점에 대해서 알아보자
- 자원의 효율성이 증가된다.
    - 멀티 프로세스로 작업하던 작업을 멀티 스레드로 작업할 경우 생성해야하는 프로세스 자원과 시스템콜이 줄어들기 때문에 자원을 효율적으로 관리할 수 있다.
    - 프로세스간의 Context Switching시에 CPU, 레지스터의 교환 뿐만 아니라 RAM과 CPU 사이의 캐시메모리까지 초기화해야하기 때문에 오버헤드가 크기 때문이다.
- 처리비용, 응답시간의 단축
    - 또한 프로세스 간의 통신(IPC)보다 스레드간의 통신의 비용이 싸게 먹히기 때문에 작업들 간의 통신의 부담이 줄어든다.
        - 스레드는 Stack을 제외한 영역의 메모리를 공유하기 때문이다.
    - 프로세스간에 전환하는 속도보다 스레드간에 전환하는 속도가 더 빠르다.
        - Context Switching시에 스레드는 Stack 영역만 처리하기 때문이다.
- 하지만 멀티 스레드를 사용하게 되면 **동기화 문제**를 주의해야한다.
- 스레드간의 자원공유는 전역변수(데이터 세그먼트)를 이용하므로 상용할 때 충돌이 발생할 수도 있다.
- Thread Safe
    - 멀티스레드 환경에서 여러 스레드가 동시에 같은 공유자원에 접근할 때 의도한 대로 동작하는 것을 말한다.
    - Thread Safe 하게 구현하기 위해서는 공유자원에 접근하는 ciritical section을 동기화 기법으로 제어해주어야한다.
    - 동기화 기법으로는 Mutext나 Semaphore가 있다.
    - Reentrant
        - 어떤 함수가 Reentrant하다는 것은 여러스레드가 동시에 접근해도 항상 같은 실행결과를 보장한다는 의미이다.
        - 이를 만족하기 위해서 해당 서브루틴에서 공유자원을 사용하지 않으면 된다.
            - 정적(전역)변수를 사용하거나 반환하지 않고 함수 호출시에 주어진 매개변수만으로 동작하면 된다.
        - Reentrant하다면 Thread-Safe하지만, Thread-Safe하다고 해서 Reentrant한 것은 아니다.

**정리하면**
- 멀티 스레드
    - 장점
        - 멀티 프로세스보다 적은 메모리 공간을 차지한다.
        - Context Switching이 빠르다
    - 단점
        - 오류로 인해서 하나의 스레드가 종료되면 전체 스레드가 종료될 수 있다는 문제점이 있다.
- 멀티 프로세스
    - 장점
        - 하나의 프로세스가 죽더라도 다른 프로세스에는 영향을 끼치지 않고 정상적으로 수행된다는 장점
    - 단점
        - 멀티스레드보다 많은 메모리 공간과 CPU시간을 차지한다.

대상 시스템에 따라서 적합한 동작방식을 선택해야한다.

[처음으로](#운영체제)

## 스케줄러
프로세스를 스케줄링하기 위한 큐에는 세가지 종류가 존재한다.
- Job Queue: 현재 시스템 내에 있는 모든 프로세스의 집합
- Ready Queue: 현재 메모리 내에 있고, CPU 시간을 할당받기를 기다리는 프로세스의 집합
- Device Queue: Device I/O작업을 대기하고 있는 프로세스의 집합
이러한 각각의 큐에 프로세스들을 넣고 빼주는 스케줄러에도 세가지 종류가 존재한다.

### 장기 스케줄러
> 사용할 수 있는 메모리들은 한정되어 있는데 많은 프로세스들이 한꺼번에 메모리에 올라올 경우, 디스크에 임시로 저장된다. 여기 저장되어 있는 프로세스중 어떤 프로세스를 Ready Queue로 보낼지 결정하는 역할을 한다.

- 메모리와 디스크 사이의 스케줄링을 담당한다.
- 프로세스에 메모리를 할당한다.
- 실행중인 프로세스의 수(degree of Multiprogramming)을 제어한다. <-- 중요!
- 프로세스의 상태는 `new -> ready`

### 단기 스케줄러
> 메모리에 올라와 있는 프로세스 중 어떤 프로세스에게 CPU를 할당할지를 결정한다.

- 메모리와 CPU사이의 스케줄링을 담당한다.
- Ready Queue에 있는 프로세스 중 어떤 프로세스를 running시킬지 결정한다.
- 프로세스에 CPU를 할당한다.(`scheduler dispatch`)
- 프로세스의 상태는 `ready -> running -> waiting -> ready`

### 중기 스케줄러
- 여유공간의 마련을 위해 프로세스를 통째로 메모리에서 디스크로 좇아낸다(swapping), 다른말로하면 프로세스를 메모리에서 해제(deallocated)시킨다.
- degree of Multiprogramming을 제어하기 위해서 사용한다.
- 현재 시스템에서 메모리에 너무 많은 프로그램이 올라오는 것을 제어하기 위해서 사용한다.
- 프로세스의 상태는 `ready -> suspended`

### 프로세스의 suspended 상태?
- 외부적인 이유로 프로세스의 수행이 정지된 상태. 메모리에서 완전히 내려간 상태를 말한다.
- 메모리에서 디스크로 전부 `swap out`된다.
- blocked된 상태는 Device I/O작업을 기다리는 상태이기 때문에 스스로 ready 상태로 돌아갈 수 있지만 이 상태는 외부적인 이유로 suspending되었기 때문에 스스로 돌아갈 수 없다.

[처음으로](#운영체제)

## CPU 스케줄러

스케줄러에서 스케줄링할 대상은 Ready Queue에 있는 프로세스를 대상으로 한다.
### FCFS(First Come First Serve)
- 먼저온 작업을 먼저 처리해주는 방식이다.
- `Non-preemptive` 스케줄링
    - CPU를 잡으면 작업이 완료될 때까지 CPU를 반환하지 않는다. 할당되었던 CPU가 반환될 때만 스케줄링이 이루어진다.
- 소요시간이 긴 프로세스가 먼저 도달하게 되면 효율성이 낮아진다.

### SJF(Shortest-Job-First)
- 다른 프로세스가 먼저 도착했어도 CPU사용시간이 짦은 프로세스에게 CPU가 먼저 할당된다.
- `Non-preemptive` 스케줄링 방식이다.
- `starvation`
    - 효율성을 추구하는 것이 가장 중요하긴 하지만, 수행시간이 긴 프로세스가 영원히 CPU를 할당받지 못할수도 있다.

### SRTF(Shortest Remaing Time First)
- `SJF`의 preemtive한 버전이라고 생각하면 편하다.
- 새로운 프로세스가 도착할 때마다 새로운 스케줄링이 이루어진다.
- 선점형(`Preemptive`) 스케줄링
    - 현재 수행중인 프로세스의 남은 CPU 타임보다 더 짧은 CPU 타임을 가지는 프로세스가 도착하면 더 짧은 프로세스에게 CPU를 넘겨주는 스케줄링 방식이다.
- `starvation`
    - `SJF`와 동일하게 `starvation`문제가 있다.

### Priority-Scheduling
- `SJF`나 `SRTF`에서는 시간 짧게 걸리는 작업이 높은 우선순위를 가지고 처리되었다. 하지만 우선순위가 낮은 프로세스는 계속해서 뒤로 밀려서 CPU를 할당받지 못할수도 있는데, 이를 `starvation`이라고 한다.
- 우선순위가 가장 높은 프로세스에게 CPU를 할당하는 스케줄링을 말한다.
- Preemptive Scheduling
    - 더 높은 우선순위의 프로세스가 도착하면 실행중인 프로세스를 멈추고 CPU를 선점한다.
- Non-Premmptive Scheduling
    - 더 높은 우선순위의 프로세스가 도작하면 Ready Queue의 Head에 넣는다.
- 우선순위가 낮은 프로세스는 계속해서 뒤로 밀려서 CPU를 할당받지 못하는, `starvation`문제가 발생할 수 있다.
- 우선순위가 낮았던 프로세스라도 오래 기다리면 높은 우선순위를 주는 `aging`이라는 방법을 사용해서 해결한다.

### Round-Robin (~~정보처리기사 시험에서 갑자기 기억이 나지 않아서 쓰지 못했던~~)
- interactive한 작업을 할 때 현대에 보편적으로 사용할 수 있는 방법이다.
- 각 프로세스가 동일한 크기의 할당시간(time quantum)을 가지게 된다.
- 할당시간이 지나면 CPU가 다른 프로세스에게 선점당하고 ready queue의 가장 뒤에가서 다시 줄을 선다
- CPU사용시간이 랜덤한 프로세스들이 섞여있을 때 효율적이다.
- 프로세스의 context를 save할 수 있기 때문에 가능한 방식이다.
- 응답이 빠르다는 장점이 있지만, context switching이 자주 일어나는만큼 오버헤드가 많이 소모된다는 단점이 있다.

> ⚠️ 주의점<br>
> `time quantum`이 너무길어지면 `FCFS` 알고리즘과 다를바 없어진다.<br>
> `time quantum`이 너무 짧으면 context switching이 그만큼 자주일어나 오버헤드가 많이 소모된다.<br>
> 따라서 적절한 수준의 `time quantum`을 찾는 것이 중요하다.

[처음으로](#운영체제)

## 프로세스 동기화
### `Critical Section`
- 앞의 멀티스레딩의 문제점에서도 보았듯이, 동일한 자원에 동시에 접근하는 작업을 실행하는 **코드 영역**을 `Critical Section`이라 부른다.

### Critical Section Problem(임계 영역문제)
- 프로세스들이 `Critical Section`을 함께 사용할 수 있는 프로토콜을 설계해야한다.
- 해결을 위한 기본 조건
    - Mutual Exclusive(상호 배제)
        - 하나의 프로세스가 `Critical Section` 내부에서 시행중이라면, 다른 프로세스들은 그들이 거쳐야하는 `Critical Section`에서 실행될 수 없다.
    - Progress(진행)
        - `Ciritical Section`에서 실행중인 프로세스가 없고, 별도의 동작이 없는 프로세스들만 `Ciritcal Section`의 진입 후보가 될 수 있다.
    - Bounded Waiting(한정된 대기)
        - 어떤 프로세스가 `Ciritical Section`에 진입 신청 후부터 받아들여질 때까지, 다른 프로세스들이 `Ciritical Section`에 진입하는 횟수는 제한이 있어야한다.

### 동기화 문제 해결책
### Mutex Lock
- 공유자원에 동시에 접근하는 것을 막기 위해서 Ciritical Section에 진입하는 프로세스가 Lock을 획득하고, 나올때 Lock을 방출해서 동시에 접근되지 않도록 하는 방법이다.
- 하지만 다중 처리기 환경에서는 시간적인 효율성 측면에서 적용할 수 없다.
### Semaphore(세마포어)
- Mutex Lock과 마찬가지고 Critical Section에 접근하는 문제를 해결하기 위해서 만든 동기화 도구이다.
- 세마포어에는 Counting/Binary Semaphore 추가지 종류가 있다.
    - 카운팅 세마포어(Counting Semaphore)
        - 세마포어의 개수만큼 스레드가 자원에 접근할 수 있다.
        - 당연히 자원에 접근할 수 있는 수만큼 세마포어 값이 초기화된다.
        - 자원을 사용하면 세마포어가 감소, 방출하면 세마포어가 증가한다.
    - 이진 세마포어(Binary Semaphore)
        - MUTEX라고도 부르며, 상호배제의(Mutext Exclusive)의 머릿글자를 따서 만들어졌다.
        - 이름처럼 0과 1사이의 값만 가능하다. 다중 프로세스들 사이의 Critical Section 문제를 해결하기 위해서 사용한다.
- 단점
    - Busy Waiting
        - spin lock이란 만약 다른 스레드가 lock을 소유하고 있다면, 그 lock이 반환될 때까지 계속 확인하며 기다리는 것이다.
        - 말 그대로 바쁘게 기다리는 Busy Waiting이다. Critical Section에 진입해야 하는 프로세스가 진입코드를 계속 반복해서 실행해야한다.
        - CPU 시간을 낭비하게 된다.
        - 해결방법으로는 Semaphore에서 Ciritical Section에 접근하려다 실패한 프로세스를 Block 시킨 다음에 Ciritical Section에 자리가 났을 때 깨우는 방식을 사용한다.
            - Busy Waiting으로 인한 시간 낭비 문제가 해결된다.
### Deadlock(교착상태)
- 세마포어가 Ready Queue를 가지고 있고, 둘 이상의 프로세스가 Critical Section의 진입을 무한정 기다리고 있고, Ciritical Section에서 실행되는 프로세스는 진입 대기중인 프로세스가 실행되어야만 빠져나올 수 있는 상황을 지칭한다.

[처음으로](#운영체제)

## 메모리 관리 전략
### 메모리를 왜 관리해?
- 각각의 프로세스가 독립된 메모리 공간을 가지고, 운영체제 혹은 다른 프로세스의 메모리 공간에 접근할수 없는 제한이 걸려있다. 운영체제만이 운영체제 메모리영역과 사용자 메모리 영역의 접근에 제약을 받지 않으면서 메모리를 관리할 수 있다.

### Swapping
- 메모리 관리를 위해서 사용되는 기법이다.
- 메모리가 할당된 프로세스가 너무 많거나 CPU할당시간이 끝난 프로세스의 메모리를 보조 기억장치(하드디스크 등)으로 내보내고 다른 프로세스의 메모리를 불러들일 수 있다.

    > 이러한 과정을 swap이라고 한다. 주 기억장치(RAM)으로 불러오는 과정을 swap-in이라 하고, 디스크로 내보내는 것을 swap-out이라고 한다.
    > swap에는 소요시간이 많이 들어가기 때문에 현재는 메모리공간이 부족할때 주로 수행한다.

### 단편화(Fragmentation)
- 프로세스들이 메모리에 적재되고 삭제되다보면 메모리 공간 사이사이에 자유공간들이 늘어나게 되는데 이것을 단편화(Fragmentation)이라고 부른다. 단편화에는 두가지 종류가 있다.

    |`A 프로세스`|free|`B 프로세스`|free|`C 프로세스`|free|`D 프로세스`|
    |:-:|:-:|:-:|:-:|:-:|:-:|:-:|

    - `외부단편화`: RAM에서 사용하지 못하게 되는 부분들을 모두 합치면 충분한 공간이 되는 부분들이 분산되어있는 경우를 말한다.
    - `내부단편화`: **프로세스가 사용하는** 메모리 공간에 포함된 남는 부분을 말한다.

- 해결책: compaction(압축)
    - 외부 단편화를 해소하기 위해서 프로세스가 사용하는 메모리 공간을 한쪽으로 몰아서 자유공간을 확보하는 방법이다.
    - 작업 효율이 좋지 않다는 단점이 있다.

    |`A 프로세스`|`B 프로세스`|`C 프로세스`|`D 프로세스`|free|free|free|
    |:-:|:-:|:-:|:-:|:-:|:-:|:-:|

### Paging(페이징)
- 하나의 프로세스가 사용하는 메모리 공간이 연속이어야 한다는 제약을 없애버린 메모리 관리 기법이다.
- 앞에서 본 외부단편화와 압축 작업을 해소하기 위해서 생긴 방법론이다.
- 물리메모리는 `frame`이라는 고정 크기로 분리되어있고, 논리메모리는 `page`라고 불리는 고정크기의 **블록**으로 분리된다.
- 페이징 기법을 사용해서 논리 메모리가 물리메모리에 저장될 때 연속되어 저장될 필요가 없어진다. 물리메모리의 남는 공간에 적절하게 배치됨으로써 외부 단편화를 해결할 수 있다는 큰 장점이 있다.
- 하지만 내부단편화 문제의 비중이 늘어난다는 단점이 있다.

### Segmentation(세그멘테이션)
- 페이징이 프로세스의 메모리 공간을 물리적으로 일정한 길이로 나눈 것이라면 세그먼트는 프로세스의 논리적인 내용을 기반으로 해서 메모리에 배치한다. 세그먼트의 길이는 일반적으로 같지 않다.
- 세그먼트 번호 + 변위, 세그먼트 테이블에는 각 세그먼트의 기준(세그먼트의 시작 물리주소)와 한계(세그먼트의 길이)를 저장한다.
- 서로 다른 크기의 세그먼트 들이 메모리에 적재되고 삭제되는 일이 반복되다 보면, 자유공간이 많아져 외부단편화가 일어날 수 있다.
- 세그먼트의 크기는 일정하지 않기 때문에 limit가 주어진다. 이 세그먼트의 크기를 넘어서는 주소가 들어오면 인터럽트가 발생해서 해당 프로세스를 강제로 종료시킨다.

## 가상메모리
- 프로세스 전체가 메모리 내에 올라오지 않더라도 실행이 가능하도록 하는 기법이다.
- 프로그램이 물리메모리보다 커도 된다는 주요 장점이 있다.
### 개발 배경
- 원래는 **실행하려는 코드의 전부를 물리메모리에 존재시켜야 했다.**
- **메모리 용량보다 큰 프로그램은 실행시킬 수 없었다.**
- 여러 프로그램을 동시에 메모리에 올리기에는 용량의 한계, 페이지 교체등의 성능 이슈가 발생했다.
- 별로 사용되지 않는 코드들이 메모리를 차지하는 것을 보고 전체 프로그램이 메모리에 올라와있을 필요는 없다는 것을 알게 되었다.

**프로그램의 일부만 메모리에 올릴 수 있다면?**

- 물리메모리의 크기에 제약받지 않게 된다.
- 더 많은 프로그램을 동시에 실행할 수 있게 된다. `응답시간`은 유지되고, `CPU이용률`과 `처리율`은 높아진다.
- `swap`에 필요한 입출력이 줄어들기 때문에 프로그램이 빠르게 실행된다.

### 가상메모리가 하는 일
- 실제의 물리 메모리 개념과 사용자의 논리메모리 개념을 분리하였다.
- 작은 메모리를 가지고도 큰 `가상 주소공간을` 프로그래머에게 제공할 수 있다.

**가상 주소공간이 뭔가요?**
- 한 프로세스가 메모리에 저장되는 논리적인 모습을 가상메모리에 구현한 공간.
- 직접적으로 필요하지 않은 메모리 공간은 실제 물리메모리에 올리지 않는 방법으로 물리메모리를 절약할 수 잇다.
- 한 프로그램에 100KB가 요구되었고, 실행까지에 필요한 메모리 공간(Stack, Heap, Code, Data)의 합이 40KB라면, 실제 물리메모리에는 40KB만 올라가 있고, 나머지 60KB는 필요시에 물리메모리에 요구하게 된다.

**프로세스간 페이지 공유**

가상메모리는...

- `시스템 라이브러리`가 여러 프로세스들 사이에서 공유될 수 있도록 해준다. 라이브러리에 올라가있는 `물리 메모리 페이지`들은 모든 프로세스에 공유되고 있다.
- 프로세스들이 메모리를 공유하는 것을 가능하게 하고, 프로세스들이 공유메모리를 통해 통신할 수 있다. 각프로세스들은 자신의 주소공간처럼 인식하지만, 실제 물리메모리는 공유되고 있는 것이다.

### **Demand Paging(요구 페이징)**
- 프로그램 시작시에 프로그램 전체를 디스크에서 메모리로 적재하는 대신, 초기에 필요한 것들만 적재하는 전략을 말한다.
- 가상메모리 시스템에서 많이 사용되며, 가상메모리는 대개 페이지로 관리된다.
- 실행과정에서 **필요해질 때** 페이지들이 적재된다. 즉, **한 번도 접근되지 않은 페이지는 물리메모리에 올라가지 않는다.**
- 프로세스 내의 개별 페이지들은 `페이저(pager)`에 의해서 관리된다. 페이저는 프로세스 실행에 실제 필요한 페이지들만 메모리로 읽어 옮으로써, 사용되지 않을 페이지를 가져오는 시간낭비와 메모리낭비를 줄일 수 있다.

### 페이지 교체
- 프로그램 실행시에 모든 항목이 물리메모리에 올라오지 않기 때문에 프로세스의 동작에 필요한 페이지를 요청하는 과정에서 page fault가 발생하게 되면 원하는 페이지를 보조저장장치에서 가져오게 된다.
- 모든 물리메모리가 사용중이라면 페이지 교체가 이루어져야한다.

**기본적으로 물리메모리가 모두 사용중인 상황에서의 흐름은 다음과 같다.**

1. 디스크에서 필요한 페이지의 위치를 찾는다.
2. 페이지의 빈 프레임을 찾는다.
    - `페이지 교체 알고리즘`을 통해 희생될(victim)페이지를 고른다.
    - 희생될 페이지를 디스크에 기록하고, 관련 페이지 테이블을 수정한다.
3. 새롭게 비워진 페이지 테이블 프레임에 새 페이지를 읽어오고, 프레임 테이블을 수정한다.
4. 사용자 프로세스 재시작

**페이지 교체 알고리즘은 다음과 같다.**

- FIFO 페이지 교체
    - 가장 간단한 페이지교체 알고리즘이다.
    - 이름 그대로, 먼저 물리메모리에 들어온 페이지 순서대로 교체시점에 먼저 나가게 된다.
    - 장점
        - 이해하기도 쉽고, 구현하기 쉽다.
    - 단점
        - 오래된 페이지가 항상 불필요한 정보를 가지고 있지는 않다. (ex.전역변수)
        - 처음부터 활발하게 사용되는 페이지를 교체해서 페이지 부재율을 높이는 부작용을 초래할 수 있다.
        - `Balady의 모순`: 페이지를 저아할 수 있는 페이지 프레임의 수를 늘려도 되려 페이지의 부재가 더 많이 발생하는 모순이 존재한다.
- 최적 페이지 교체(Optimal Page Replacement)
    - 앞으로 가장 오랫동안 사용되지 않을 페이지를 찾아서 교체하는 것이다.
    - 알고리즘 중 가장 낮은 페이지 부재율을 보장하지만, 프로세스의 메모리 참조 계획을 미리 파악할 방법이 없기 때문에 구현에 어려움이 있다.
- LRU 페이지 교체(LRU Page Replacement)
    - 가장 오랫동안 사용되지 않은 페이지를 선택하여 교체하는 방법이다.
    - FIFO보다 우수하고, OPT보다는 그렇지 않다.
    - 현실성있는 교체 알고리즘 중에서는 제일 좋다.



