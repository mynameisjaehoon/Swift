# 네트워크

- [OSI 7계층](#osi-7계층)
- [3 Way Handshake & 4 Way Handshake](#3-way-handshake--4-way-handshake)
    - [3 Way Handshake](#3-way-handshake)
    - [4 Way Handshake](#4-way-handshake)
- [TCP/UDP, 흐름제어, 혼잡제어](#tcpudp-흐름제어-혼잡제어)
    - [흐름제어](#흐름제어)
    - [혼잡제어](#혼잡제어)

---


## OSI 7계층
- 7계층을 나누는 이유
    - 통신이 일어나는 과정을 단계별로 알 수 있고, 특정한 곳에 이상이 생겼을 때 그 단계만 수정할 수 있기 때문이다.
- OSI 7계층
    1. 응용계층
        - 최종 목적지로, 응용서비스와 직접 관계해서 일반적인 응용서비스를 수행하는 계층이다.
    2. 표현계층
        - 데이터 표현에 대한 독립성을 제공하고 암호화하는 역할을 제공한다.
    3. 세션계층
        - 데이터가 통신하기 위한 논리적인 연결을 담당한다.
    4. 전송계층
        - TCP, UDP 프로토콜을 통해서 통신을 활성화환다.
    5. 네트워크계층
        - 데이터를 목적지까지 가장 빠르고 안전하게 전달하는 기능을 담당한다.
        - 라우터를 통해 이동한 경로를 선택하여 IP주소를 지정하고, 해당 경로에 따라서 패킷을 전달한다.
        - 라우팅, 흐름제어, 오류제어, 세그멘테이션을 수행
    6. 데이터-링크계층
        - 물리 계층으로 송수신 되는 정보를 안전하게 전달되도록 관리한다. Mac주소를 통해서 통신한다.
    7. 물리계층
        - 데이터를 전기적인 신호로 변환핸서 전송하는 역할을 한다.

## 3 Way Handshake & 4 Way Handshake
### 3 Way Handshake
TCP는 정확한 전송을 보장해야 하기 때문에 전송하기에 앞서 논리적인 접속을 활성화 하기 위해서 3 Way Handshake를 진행합니다.
1. 클라이언트가 서버에서 SYN패킷을 보낸다.
2. 서버가 SYN을 받고, 클라이언트로 받았다는 신호인 ACK와 SYN을 보낸다.
3. 클라이언트는 서버의 응답이 ACK, SYN 을 받고, ACK를 서버로 보낸다.

### 4 Way Handshake
연결 성립 후 모든 통신이 끝났을 때 해제해야하는 것이다.
1. 클라이언트가 서버에게 연결을 종료한다는 FIN 플래스를 보낸다.
2. 서버에서 FIN을 받고, 확인했다는 ACK를 클라이언트에게 보낸다(이때 모든 데이터를 보내기 위해 CLOSE_WAIT 상태가 된다)
3. 데이터를 모두 보냈다면 연결이 종료되었다는 FIN플래그를 클라이언트에게 보낸다.
4. 클라이언트가 FIN을 받고, 확인했다는 ACK를 서버에게 보낸다. (클라이언트는 아직 서버에서 받지 못한 데이터가 있을 수도 있으므로 TIME_WAIT을 통해 기다린다.)
    - 서버는 ACK를 받은 이후 소켓을 닫느다.
    - TIME_WAIT시간이 끝나면 클라이언트도 닫는다.

## TCP/UDP, 흐름제어, 혼잡제어
- TCP
    - 네트워크에서 신뢰적인 통신방식
    - reliable network를 보장한다는 것은 4가지 문제점을 지원한다는 것이다.
        1. 손실: 패킷이 손실될 수 있는 문제
        2. 순서: 패킷의 순서가 바뀔수 있는 문제
        3. Congestion: 네크워크가 혼잡한 문제
        4. Overload: receiver가 overload되는 문제
- UDP
    - User Data Protocol의 약자로, 데이터를 데이터그램 단위로 처리하는 프로토콜
    - 비연결성, 신뢰성없는 전송 프로토콜이다.
    - 왜 필요함?
        1. IP의 역할은 Host to Host만을 지원한다. 장치에서 장치로의 이동은 IP로 해결되지만, 하나의 장비 안에서 여러 프로그램들이 통신해주어야 할 경우에는 IP만으로 한계가 있다.
    - UDP의 경우에는 IP가 제공하는 정도의 수준만을 제공하는 간단한 IP상위 계층의 프로토콜이다.
    - 결정적인 장점은 **데이터의 신속성**이다. 데이터의 처리가 TCP보다 빠르다.
    - 주로 실시간 방송이나 온라인 게임에서 사용된다. 
- 흐름제어, 혼잡제어란?
    - 흐름제어
        - 송신측과 수신 측의 데이터 처리속도 차이로 인해 발생하는 문제를 해결하는 것
        - 수신측에서 지나치게 많은 패킷을 받지 않도록 하는 것이다.
        - 기본 개념은 수신측에서 송신측에게 현재 자신의 상태를 피드백 함으로써 이루어진다.
    - 혼잡제어
        - 송신측의 데이터 전달과 네트워크의 데이터 전달속도 차이로 인해 발생하는 문제를 해결하는 것
### 흐름제어
- 수신측이 송신측보다 데이터처리속도가 빠를때는 상관없지만 송신측이 더 빠를때는 문제가 발생한다.
- 수신측에서 제한한 용량을 넘어서 데이터가 도착할 경우에는 데이터가 손실될 수 있고
- 이러한 위험을 줄이기 위해서 송신측에서 수신측의 상태에 따라 보내는 데이터의 양을 조절해야한다.
- 해결방법
    - `Stop And Wait`: 매번 전송한 패킷에 대해 확인을 받아야만 다음 패킷을 전송하는 방법
    - Sliding Window
        - 수신측에서 설정한 윈도우 크기만큼 송신측에서 확인없이 세그먼트를 전송할 수 있도록 하여 데이터 흐름을 동적으로 조절하는 제어기법
        - 동작방식
            - 먼저 윈도우에 포함되는 모든 패킷을 전송하고, 그 패킷들의 전송이 확인되는 만큼 윈도우를 옆으로 옮기면서 다음 패킷들을 전송한다.
        - TCP/IP 통신을 하는 모든 호스트 들은 송신용 윈도우와 수신용 윈도우를 가지고 있다.
        - 3 way handshake를 통해서 수신 호스트의 윈도우사이즈에 송신 호스트의 윈도우사이즈를 맞추게 된다.

### 혼잡제어
- 송신측에 데이터는 지역망이나 대형 네트워크를 통해 전달되게 된다. 하나의 라우터에만 데이터가 몰릴 경우에는 라우터가 자신에게 온 데이터를 처리할 수 없게 되고 결국 호스트에서 데이터의 재전송이 이루어지는데 이것은 결국 혼잡을 가중시켜서 오버플로우나 데이터의 손실을 불러올 수 있다.
- 이러한 네트워크의 혼잡을 피하기 위해서 송신측에서 보내는 데이터의 수를 강제로 줄이게되는데 이것을 혼잡제어 라고한다.
- 해결법
    - AIMD(Additive Increase / Multiplicative Decrease)
        - 처음에 패킷을 하나 보내고, 문제없이 도착하면 window의 사이즈를 1씩 증가시키는 방법이다.
        - 패킷 전송에 실패하면 window의 사이즈를 절반으로 줄인다.
        - 공평한방법이라는 장점이 있고, 여러 호스트들이 같은 네트워크에 진입할 때 처음에는 나중에 진입하는 호소트가 불리할 수 있지만 시간이 흐르면 평형상태로 수렴한다는 특징이 있습니다.
        - 하지만 윈도우 사이즈를 1씩 증가시킨다는 점에서 처음에는 높은 대역폭을 사용하지 못한다는 점과, 네트워크의 혼잡을 미리 아는 것이 아닌 혼잡을 경험 한 다음에 window를 감소시킨다는 점에서 네트워크의 혼잡을 미리 감지하지 못한다는 단점이 있습니다.
    - Slow Start(느린 시작)
        - AIMD방식이 네트워크 수용량 주변에서는 효율적으로 동작하지만 초반에는 전송속도를 올리는데 시간이 오래 걸린다는 단점이 있습니다.
        - Slow Start 방식은 AIMD 처럼 패킷을 하나 보내면서 시작하고 패킷 하나가 문제없이 도착할 때 ACK 패킷하나마다 window의 크기를 1씩 증가 시키는 방식입니다. 즉, 한 주기가 지나면 윈도우의 크기는 2배가 됩니다.
        - 전송속도는 AIMD와 비교해서 지수함수 꼴로 증가합니다.
        - 혼잡 현상이 발생하면 window 크기를 1로 감소시킵니다.
        - 처음에는 네트워크 수용량을 예상할 수 있는 정보가 없지만 한번 혼잡 현상이 발생하고 나면 네트워크 수용량을 어느정도 예측할 수 있습니다. 
        - 혼잡 현상이 발생하였던 윈도우 크기까지는 지수함수 꼴로 증가시키고 그 이후로는 1씩 증가시킵니다.
    - Fast Recovery(빠른 회복)
        - 혼잡이 발생하였을 때 window 크기를 1로 줄이지 않고, 절반으로 줄인 다음에 선형적으로 증가시키는 방법입니다. 
        - 혼잡이 한번 발생한 이후로는 순수한 AIMD방식으로 동작하게 됩니다. 

# Question

- **OSI7계층에 대해서 설명해주세요**
    - 응용계층은 최종 목적지로, 응용프로세스와 직접 관계하여 일반적인 응용 서비스를 수행합니다. 사용자 인터페이스, 전자우편, 데이터베이스 관리등의 서비스를 제공합니다.
    HTTP, FTP, SSH, DNS
    - 표현계층은 데이터 표현에 대한 독립성을 제공하고 암호화 하는 역할을 담당합니다. 파일 인코딩, 명령을 포장, 압축, 암호화 합니다.
    SSL, SSH, FTP, JPEG
    - 세션계층은 데이터가 통신하기위한 논리적인 연결을 담당하니다. TCP/IP 세션을 만들고 없애는 책임을 지니고 있습니다.
    API’s, Sockets
    - 전송계층은 TCP와 UDP프로토콜을 통해 통신을 활성화 합니다. 포트를 열어두고, 프로그램들이 전송을 할 수 있도록 제공해줍니다.
    TCP, UDP
    - 네트워크 계층은 데이터를 목적지까지 가장 안전하고 빠르게 전달하는 기능을 담당합니다. 라우터를 통해 이동할 경로를 선택하여 IP주소를 지정하고, 해당경로에 따라 패킷을 전달해줍니다. 라우팅, 흐름제어, 오류제어, 세그먼테이션등을 수행합니다.
    IP, ICMP
    - 데이터 링크계층은 물리계층으로 송수신되는 정보를 관리하여 안전하게 전달되도록 합니다. 네트워크 카드가 발급될때부터 나오는 Mac주소를 통해 통신하고, 프레임에 Mac주소를 부여하고 에러검출, 재전송, 흐름제어를 진행합니다.
    Ethernet
    - 물리계층은 단지 데이터를 전기적인 신호로 변환해서 주고받는 기능을 진행하는 공간입니다. 즉 데이터를 전송하는 역할만 진행합니다.
    Fiber, Coax
    - 데이터 링크 계층에서 오류를 검출하는 기법을 아는대로 설명해보시오
        
        패리티 비트 검사, 해밍부호 검사 등이 있습니다.
        
    - DNS란 무엇인가?
        
        네이버와 구글과 같은 도메인 이름을 IP주소로 변환하는 기법을 말한다.
        
    - 전송계층과 네트워크 계층간의 차이점에 대해 말해주세요
        
        [Difference between Transport Layer and Network Layer - Scaler Topics](https://www.scaler.com/topics/computer-network/difference-between-transport-layer-and-network-layer/)
        
        전송계층은 OSI의 네번째 계층이고, 네트워크계층은 세번째 계층이고, 전송계층은 프로세스간의 논리적인 통신을 처리하고, 네트워크계층은 호스트간의 논리적통신을 처리합니다. 그리고 전송계층은 데이터 전달을 처리하는 프로세스 중점을 두고 네트워크 계층은 서로다른 네트워크의 호스트간의 통신 제공합니다. 전송계층은 상위계층에서 데이터를 수신해서 세그먼트라고하는 더 작은 것으로 변환하고 네트워크 계층은 전송계층에서 받은 데이터를 패킷 형태로 나눕니다. 또 전송계층은 데이터의 순서를 유지하는데 집중하지만 네트워크계층은 집중하지 않는다는 점도 있고 전송계층에서 상요되는 프로토콜은 TCP, UDP가 있고 그리고 네트워크 계층에서 사용되는 다양한 프로토콜은 IPv4, IPv6, ICMP등이 있습니다. 그리고 전송계층에서 사용되는 다양한장치에는 세그먼트와 로드밸런서등이 있고 네트워크 계층에서 사용되는 장치는 라우터가 있습니다.
        
- **3-way-handshake와 4-way-handshake에 대해 설명해주세요**
    
    3-way-handshake는 TCP가 신뢰적인 통신을 제공하기 위해서 데이터를 전송하기에 앞서 수행하는 과정입니다. 먼저 클라이언트가 서버에게 통신을 시작한다는 SYN패킷을 보내면 그것을 받은 서버가 클라이언트에게 ACK패킷을 보내게 되고, 이것을 받은 클라이언트가 서버에게 ACK 패킷을 보냅니다. 이렇게 세번의 통신이 완료되면 연결이 성립됩니다.
    
    - 2-way-handshake는 왜 안되나요?
        
        클라이언트가 서버에게 연결요청을 한것에 대한 서버의 응답이 딜레이가 많이 되어서 다시 연결요청한 후에 도착했다면 서버측에서 과거의 연결요청에 대한 순서번호로 응답이 오게 되고, 클라이언트는 잘못된 순서 번호의 패킷이 왔기 때문에 그 패킷을 버리게 됩니다. 이런상황에서 2-way handshake가 끝이라면 서버입장에서는 클라이언트가 응답을 제대로 받았는지 확인할 수 없고 연결이 성립되었다고 오해할 수 있기 때문입니다.
        
- **4-way-handshake에 대해 설명해주세요.**
    
    4-way-handshake는 연결이 성립된 후 모든 통신이 끝났다면 해제할 때 거치는 과정을 말합니다. 클라이언트가 서버에게 연결을 종료한다는 FIN플래그를 보내고 이를 받은 서버가 클라이언트에게 ACK를 보내고, 아직 전송하지 못한데이터가 있다면 다 전송한 다음 FIN플래그를 보냅니다. FIN을 받은 클라이언트는 아직 전송받지 못한 데이터가 있을 수 있으므로 TIME_WAIT시간동안 기다리게 되고, 시간이 다 지나면 서버에게 ACK를 보냅니다. ACK를 받은 서버는 소켓을 닫게되고, 클라이언트는 TIME_WAIT시간이 지나게 되면 소켓을 닫으면서 이렇게 4번의 통신으로 연결이 해제되게됩니다.
    
- **IPv4와 IPv6의 차이에 대해 말해주세요.**
    
    예전부터 사용되던 IPv4는 32비트 주소체계입니다. 이 32비트만으로 주소를 표현하기에는 부족해졌기 때문에 128비트를 사용하는 IPv6가 등장하였습니다. IPv4는 8비트 4부분 10진수로 표시하고, IPv6는 16비트의 8부분을 16진수로 표시합니다. 헤더의 크기도 v4는 가변, v6는 고정이라는 차이점이 있습니다.
    
- **ICMP프로토콜에 대해 설명해주세요.**
    
    인터넷 제어메세지 프로토콜로 인터넷 통신상에서 발생한 오류를 전송하는데 사용됩니다. IP프로토콜을 이용해서 ICMP메세지를 전달합니다.
    
- **ARP프로토콜에 대해 설명해주세요.**
    
    ARP 프로토콜이란 소프트웨어적으로 할당된 주소인 IP주소를 실제적인 물리주소인 MAC주소로 바꾸어주는 역할을 하는 주소 해석 프로토콜을 의미합니다.
    
    1. 송신자가 목적지 IP주소를 지정해 패킷을 송신한다.
    2. IP프로토콜이 ARP프로토콜에게 ARP Request 메세지를 생성하도록 요청한다.
    3. 메세지는 2계층으로 전달되고 이더넷 프레임으로 캡슐화된다. 송신자의 물리주소를 발신지 Mac주소로 하고, 수신자의 물리주소를 브로드캐스트주소로 지정합니다.
    4. 모든 호스트와 라우터가 프레임을 수신한 다음 자신의 ARP프로토콜에게 전달합니다.
    5. 목적지 IP주소가 일치하는 시스템은 자신의 물리주소를 포함하고있는 ARP Reply 메세지를 보내고
    6. 요청을 보낸쪽에서 지정한 IP주소에 대응하는 Mac주소를 얻게됩니다. ARP응답은 유니캐스트 입니다.
- **TCP와 UDP에 대해 설명해주세요.**
    
    TCP는 신뢰적인 통신을 보장하는 전송계층 프로토콜 입니다. 신뢰적이라는 것은 패킷이 손실되면 안되고 순서대로 전송되는 것을 보장하고 네트워크가 혼잡할때도 패킷이 제대로 전송되어야 하고 수신측에 오버로딩이 발생해도 제대로 패킷이 전송되는 것을 보장하는 것을 말합니다. 흐름제어와 혼잡제어도 해줍니다.
    
    UDP같은경우는 신뢰적인 통신을 보장하지 않습니다. 흐름제어도 안하고 혼잡제어도 안하고 3way handshake도 안하다보니 속도가 빠르다는 것이 장점입니다. 주로 실시간 방송과 온라인게임에서 사용됩니다.
    
- **TCP와 UDP는 왜 나오게 되었나요?**
    1. IP의 역할은 Host to Host만을 지원합니다. 장치에서 장치로의 연결은 IP로 해결되지만 하나의 장치안에서 수많은 프로그램들이 통신할경우에는 IP만으로는 한계가 있습니다. 이것을 해결하기 위해서 포트번호가 나오게 되었고
    2. 또 IP에서 오류가 발생한다면 ICMP에서 알려주게 되는데 ICMP는 알려주기만할 뿐 대처를 못하기 때문에 IP윗단에서 처리해주는 과정이 필요했기 때문입니다.
- **DNS에서 주로 UDP를 사용하는 이유에 대해 설명해주세요**
    
    Request의 양이 적어서 UDP Request에 담길 수 있고, 3 way handshake로 연결을 유지할 필요가 없습니다. 그리고 Reqeust에 대한 손실은 Application Layer에서 제어가 가능합니다. UDP의 제한인 512를 넘는 용량이면 TCP를 사용해야합니다.
    
- **로드밸런싱에 대해 설명해주세요**
    
    [로드 밸런서(Load Balancer)란?](https://nesoy.github.io/articles/2018-06/Load-Balancer)
    
    로드밸런싱은 트래픽이 많아지면서 1대의 서버로 감당하기 어려워졌기 때문에 여러 서버를 두고 균등하게 트래픽을 분산시키는 것을 말합니다. 로드 밸런서를 클라이언트와 서버 사이에 두고 부하가 일어나지 않도록 여러 서버에 분산시켜 주는 방식입니다. 
    
    - **로드밸런서가 서버를 선택하는 방식에는 어떤 것이 있을까요?**
        - CPU 스케줄링의 라운드 로빈방식을 활용하는 방법
        - Least Connections: 연결개수가 가장 적은 서버를 선택하는 방법입니다. 트래픽으로 인해 세션이 길어지는 경우 권장됩니다.
        - Source: 사용자 IP를 해싱하여 분배하는 방법이 있습니다. 이 방법은 특정 사용자가 항상 같은 서버로 연결되는 것을 보장합니다.
    - 로드밸런서의 장애대비는 어떻게 할까요?
        - 로드밸런서를 이중화해서 장애를 대비할 수 있습니다.
        - 이중화된 로드 밸런서들이 서로 Health Check를 합니다.
        - Main Load Balancer가 동작하지 않으면 가상IP(VIP, Virtual IP)는 여분의 로드밸런서로 변경됩니다.
        - 여분의 로드 밸런서로 운영하게 됩니다.
    
- **blocking/non-blocking, 동기/비동기의 차이를 설명해주세요**
    
    blocking/non-blocking은 호출되는 함수가 바로 return하느냐 마느냐가 관심사 입니다. 호출된 함수가 바로 return해서 호출한 함수에게 제어권을 넘겨주고 호출한 함수가 다른일을 할 수 있는 기회를 줄 수 있으면 non-blocking입니다. 호출한 함수가 자신의 작업을 모두 마칠때까지 호출한 함수에게 제어권을 넘겨주지 않고 대기하게 만든다면 blocking입니다.
    동기/비동기는 호출되는 함수의 작업완료 여부를 누가 신경쓰느냐가 관심사 입니다. 호출되는 함수가 전달받은 콜백을 실행하고, 호출한 함수는 작업완료여부를 신경쓰지 않는다면 비동기 입니다. 하지만 호출하는 함수가 호출되는 함수의 작업완료 후 return을 기다리거나 호출되는 함수로부터 바로 return받더라도 작업 완료 여부를 호출한 함수 스스로 확인하며 신경쓴다면 동기입니다.
    
- **소켓에 대해서 설명해주세요**
    
    프로그램이 네트워크에서 데이터를 통신할 수 있도록 연결해주는 연결부라고 할 수 있습니다.
    
    클라이언트 소켓에서 연결요청을 하면, 올바른 port로 들어왔을때 서버 소켓이 허락을 하여 통신을 할 수 있도록 연결되는 것입니다.
    
- 쿠키와 세션에 대해서 설명해주세요
    
    둘다 HTTP 프로토콜의 특징인 비연결성과 비상태성때문에 필요해졌습니다. HTTP 프로토콜은 모든 요청간 의존관계가 없어서 현재 접속한 클라이언트가 이전에 접속한 클라이언트와 같은지 다른지 알 수 있는 방법이 없습니다. 또한 연결을 유지하지 않는다는 점은 불필요한 리소스를 낭비하지 않는다는 장점이 있지만 통신할때마다 새로 연결되기 때문에 클라이언트는 매 요청마다 인증과정을 거쳐야한다는 단점이 있습니다. 따라서 HTTP 프로토콜의 상태를 유지할 필요가 생겼고, 이에 쿠키와 세션 개념이 등장하였습니다.
    
    쿠키는 클라이언트의 상태정보를 브라우저 저장하여 참조합니다. name, value등이 저장되어있는 하나의 파일이고 브라우저마다 쿠키가 다르기 때문에 서버입장에서는 브라우저가 다르면 다른 사용자로 인식합니다.
    
    - 먼저 웹 브라우저(클라이언트)가 서버에 작업을 요청합니다.
    - 그러면 상태를 유지하고싶은 값에 대해 쿠키를 생성합니다.
    - 서버측에서 HTTP 헤더에 쿠키를 포함해서 전송해주고
    - 전달받은 쿠키는 웹 브라우저에 저장되었다가 다음 HTTP 요청때 헤더에 담겨서 서버에 전송됩니다.
    - 서버는 쿠키정보를 읽어서 이전상태를 확인한 후 응답합니다.
    
    방문했던 웹 사이트에 대한 정보 및 개인정보가 기록되기 때문에 사생활 침해 문제가 있을 수 있고 서버에 저장되는 것이 아닌 웹 브라우저에 저장되기 때문에 임의수정이 가능하고 보안에 취약합니다.
    
    세션은 일정시간동안 같은 브라우저로부터 들어오는 요청을 하나로 보고 그 상태를 유지하는 기술입니다. 즉 웹브라우저를 통해 서버에 접속한 이후부터 브라우저를 종료할 때까지 유지되는 상태입니다. 
    
    - SessionID로 구분되고 Session ID는 브라우저당 하나씩 생성되고, 브라우저 종료 시 소멸됩니다.
    - ID, Password등 필요한 정보를 세션에 담아두면, 요청이 있을 때마다 DB에 접근할 필요가 없기 때문에 효율적입니다.
    
    동작방식은
    
    - 웹브라우저가 서버에 요청하면
    - 서버가 해당 웹 브라우저에 유일한 ID를 부여합니다.
    - 서버가 응답할 때 HTTP의 header중 setCookie에 SessionID를 포함하여 전송합니다.
    - 웹 브라우저는 이후, 웹 브라우저를 닫기까지 다음 요청 때 부여된 Session ID가 담겨있는 쿠키를 HTTP의 header에 넣어서 전송합니다.
    - 서버는 Session ID를 확인하고, 해당 세션에 관련된 정보를 확인한 후 응답합니다.
    
    세션도 쿠키를 사용하여 값을 주고 받습니다. 다시 말해, 상태정보를 유지하는 수단은 쿠키이고, 세션은 쿠키를 사용하는 또다른 방식입니다.