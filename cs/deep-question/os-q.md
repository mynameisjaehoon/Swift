# 운영체제

<details>
<summary><h3>1. 시스템 콜이 무엇인지 설명해 주세요.</h3></summary>
<div markdown="1">     

운영체제에서 제공하는 서비스를 이용하기 위한 프로그래밍 인터페이스이다.<br> 시스템콜의 유형으로는 프로세스 제어, 파일 조작, 장치 조작, 정보 유지보수, 통신과 보호 등으로 나눌 수 있습니다.<br>
사용자 모드에서는 사용자 애플리케이션 코드가 사용되고, 접근할 수 있는 영역에 제한이 있기 때문에 해당 모드에서는 하드웨어(디스크, I/O등)에 직접적으로 접근할 수 없습니다. 접근을 위해서 시스템 콜을 사용하게 됩니다.
- **우리가 사용하는 시스템 콜의 예시를 들어주세요.**<br>
  프로세스 제어를 위한 system call중 다음을 예시로 들 수 있습니다.
  - `fork()`: 자식 프로세스 생성
  - `exec()`: 자신을 수행가능한 다른 프로세스로 대치 수행
  - `wait()`: 프로세스 종료시까지 대기
  - 이외에도 pipe, signal, exit, open, create, close, read, write등이 있습니다.
- **시스템 콜이, 운영체제에서 어떤 과정으로 실행되는지 설명해 주세요.**

  <img width="70%" src="https://user-images.githubusercontent.com/76734067/212707431-a854e8df-61a1-41cf-90cb-335dbc190c3b.png">

  1. 라이브러리 함수(예: printf)를 호출한다.
  2. 라이브러리 함수 내부에서 시스템 콜(write)를 호출한다.
  3. 시스템 콜의 인덱스를 CPU레지스터에 저장한다.
  4. 0x80 인터럽트를 발생시킨다.(커널모드로 전환)
  5. IDT(Interrupt Descriptor Table)을 참조하여 system_call()을 호출한다.
  6. 이때 `3`에서 저장한 인덱스를 system_call()함수 내에 저장한다.
  7. sys_call_table을 참조해 해당 인덱스에 맞는 기능(sys_write)을 호출한다.
  8. 수행이 모두 끝나면 사용자 모드로 전환한다.
- **시스템 콜의 유형에 대해 설명해 주세요.**<br>
  시스템 콜은 다음 6가지로 분류할 수 있습니다.
  - 프로세스 제어
  - 파일 조작
  - 디바이스 조작
  - 정보관리
  - 커뮤니케이션
  - 보안

- **운영체제의 Dual Mode 에 대해 설명해 주세요.**<br>
  이중 동작 모드(Dual-mode Operation)이란 운영체제를 보호하기 위한 기법입니다. 사용자와 운영체제는 시스템 자원을 공유하기 때문에 사용자에게 제한을 주지 않으면 사용자가 메모리 내의 주요 운영체제 자원을 망가뜨릴 위험이 생기게 됩니다. 따라서 시스템 자원 접근을 제한하는 보호장치가 필수적인데 그를 위해서 이중 동작모드를 사용하게 됩니다. **커널 모드**와 **유저 모드**라는 두가지 모드로 나뉘게 됩니다.
  - 커널모드
    - supervisor mode, system mode, privileged mode등으로도 불리운다.
    - 운영체제를 위한 동작을 담당한다.
    - 시스템의 **모든 메모리에 접근**할 수 있고 **모든 CPU명령을 실행**할 수 있다.
    - 운영체제 코드나 디바이스 드라이버 같은 커널모드 코드를 실행한다.
    - CPU는 커널모드 특권 수준에서 코드를 실행한다.
  - 유저모드
    - 사용자를 위한 동작을 담당한다.
    - 사용자 애플리케이션 코드가 실행된다.
    - 시스템 데이터에 **제한된 접근만이 허용**되며 하드웨어를 직접 접근할 수 없다.
    - 유저 애플리케이션에서 시스템 서비스를 호출하면 유저모드에서 커널모드로 전환된다.
    - 유저모드에서 실행하는 스레드는 자신만의 유저모드 스택을 가진다.

- **서로 다른 시스템 콜을 어떻게 구분할 수 있을까요?**<br>
  커널은 내부적으로 각각의 시스템 콜을 구분하기 위해 기능별로 고유번호를 할당하고 그 번호에 해당하는 제어루틴을 커널 내부에 정의하고 있습니다.

</details>

<details>
<summary><h3>2. 인터럽트가 무엇인지 설명해 주세요.</h3></summary>
<div markdown="1">   

CPU가 프로그램을 실행하고 있을 때, 입출력 하드웨어 등의 장치에 예외상황이 발생해서 CPU에게 처리할 수 있도록 알려주는 것.
- 인터럽트는 어떻게 처리하나요?<br>
  1. 실행하고 있던 프로그램의 실행을 중단합니다.
  2. 현재의 프로그램 상태를 PCB에 보존합니다.
  3. 인터럽트 처리 루틴을 실행합니다.
  4. 인터럽트 서비스 루틴을 실행합니다.
  5. 인터럽트 요청 신호가 발생했을 때 보관한 PC값을 다시 PC에 저장합니다.
  6. PC의 값을 이용하여 인터럽트 발생 이전에 수행중이던 프로그램을 계속 실행합니다.
- Polling 방식에 대해 설명해 주세요.<br>
  폴링(Polling)이란 하드웨어장치의 상태를 수시로 체크하여 명령을 받을 수 있는지를 확인하는 것을 말한다.<br>
  - Polling을 하는 동안에는 다른 프로세스에게 CPU를 양도하지 않는다.
  - 하드웨어 장치가 동작을 완료하는 동안 루프를 돌면서 하드웨어의 상태를 체크한다.
  - 하지만 이러한 동작으로 인해서 CPU를 많이 낭비하게 된다.
- 인터럽트와 폴링의 장단점<br>
  - 인터럽트를 사용하면 CPU연산과 I/O장치 작업을 중첩시켜서 수행할 수 있게 됩니다. 따라서 인터럽트를 사용하는 것이 CPU의 사용률을 높일 수 있습니다.
  - 하지만 인터럽트를 사용하게되면 context switching에서 많은 비용이 수반되기 때문에 단 한번의 폴링으로만 끝날 정도의 빠른 하드웨어 장치라면 폴링이 더 효율적이다.
- HW / SW 인터럽트에 대해 설명해 주세요.<br>
  - 하드웨어 인터럽트(외부 인터럽트)
    - 일반적으로 컴퓨터의 하드웨어에서 발생하는 것을 말합니다.
    - 전원의 이상, CPU의 기능 및 기계의 착오, 키보드 동작 또는 입출력 장치의 데이터 전송 등이 있습니다.
  - 소프트웨어 인터럽트(내부 인터럽트)
    - 프로그램 내부에서 발생하는 것으로, 잘못된 명령이나 잘못된 데이터를 사용할 때 발생합니다.
    - Trap이라고도 부릅니다.
    - 허용하지 않은 명령 또는 공간에 접근하거나, 계산결과에 대한 오버플로(Overflow)/언더플로(UnderFlow)등이 있습니다.
</details>

<details>
<summary><h3>3. 프로세스가 무엇인가요?</h3></summary>
<div markdown="1">    

- 프로그램과 프로세스, 스레드의 차이에 대해 설명해 주세요.</li>
-  PCB가 무엇인가요?</li>
- 그렇다면, 스레드는 PCB를 갖고 있을까요?</li>
-  리눅스에서, 프로세스와 스레드는 각각 어떻게 생성될까요?</li>
-  자식 프로세스가 상태를 알리지 않고 죽거나, 부모 프로세스가 먼저 죽게 되면 어떻게 처리하나요?</li>
-  리눅스에서, 데몬프로세스에 대해 설명해 주세요.</li>
 
</details>

<details>
  <summary><h3>4. 프로세스 주소공간에 대해 설명해 주세요.</h3></summary>
<ul>
<li> 초기화 하지 않은 변수들은 어디에 저장될까요?</li>
<li> 일반적인 주소공간 그림처럼, Stack과 Heap의 크기는 매우 크다고 할 수 있을까요? 그렇지 않다면, 그 크기는 언제 결정될까요?</li>
<li> Stack과 Heap 공간에 대해, 접근 속도가 더 빠른 공간은 어디일까요?</li>
<li> 다음과 같이 공간을 분할하는 이유가 있을까요?</li>
<li> 스레드의 주소공간은 어떻게 구성되어 있을까요?</li>
</ul>
</details>

<details>
  <summary><h3>5. 단기, 중기, 장기 스케쥴러에 대해 설명해 주세요.</h3></summary>
<ul>
<li> 현대 OS에는 단기, 중기, 장기 스케쥴러를 모두 사용하고 있나요?</li>
<li> 프로세스의 스케쥴링 상태에 대해 설명해 주세요.</li>
<li> preemptive/non-preemptive 에서 존재할 수 없는 상태가 있을까요?</li>
<li> Memory가 부족할 경우, Process는 어떠한 상태로 변화할까요?</li>
</ul>
</details>

<details>
  <summary><h3>6. 컨텍스트 스위칭 시에는 어떤 일들이 일어나나요?</h3></summary>
<ul>
<li> 프로세스와 쓰레드는 컨텍스트 스위칭이 발생했을 때 어떤 차이가 있을까요?</li>
<li> 컨텍스트 스위칭이 발생할 때, 기존의 프로세스 정보는 커널스택에 어떠한 형식으로 저장되나요?</li>
<li> 컨텍스트 스위칭은 언제 일어날까요?</li>
</ul>
</details>

<details>
  <summary><h3>7. 프로세스 스케줄링 알고리즘에는 어떤 것들이 있나요?</h3></summary>
<ul>
<li> RR을 사용할 때, Time Slice에 따른 trade-off를 설명해 주세요.</li>
<li> 싱글 스레드 CPU 에서 상시로 돌아가야 하는 프로세스가 있다면, 어떤 스케쥴링 알고리즘을 사용하는 것이 좋을까요? 또 왜 그럴까요?</li>
<li> 동시성과 병렬성의 차이에 대해 설명해 주세요.</li>
<li> 타 스케쥴러와 비교하여, Multi-level Feedback Queue는 어떤 문제점들을 해결한다고 볼 수 있을까요?</li>
</ul>
</details>

<details>
  <summary><h3>8. 뮤텍스와 세마포어의 차이점은 무엇인가요?</h3></summary>
<ul>
<li> 이진 세마포어와 뮤텍스의 차이에 대해 설명해 주세요.</li>
</ul>
</details>

<details>
  <summary><h3>9. Deadlock 에 대해 설명해 주세요.</h3></summary>
<ul>
<li> Deadlock 이 동작하기 위한 4가지 조건에 대해 설명해 주세요.</li>
<li> 그렇다면 3가지만 충족하면 왜 Deadlock 이 발생하지 않을까요?</li>
<li> 어떤 방식으로 예방할 수 있을까요?</li>
<li> 왜 현대 OS는 Deadlock을 처리하지 않을까요?</li>
<li> Wait Free와 Lock Free를 비교해 주세요.</li>
</ul>
</details>

<details>
  <summary><h3>10. 프로그램이 컴파일 되어, 실행되는 과정을 간략하게 설명해 주세요.</h3></summary>
<ul>
<li> 링커와, 로더의 차이에 대해 설명해 주세요.</li>
<li> 컴파일 언어와 인터프리터 언어의 차이에 대해 설명해 주세요.</li>
<li> JIT에 대해 설명해 주세요.</li>
<li> 본인이 사용하는 언어는, 어떤식으로 컴파일 및 실행되는지 설명해 주세요.</li>
</ul>
</details>

<details>
  <summary><h3>11. IPC가 무엇이고, 어떤 종류가 있는지 설명해 주세요.</h3></summary>
<ul>
<li> Shared Memory가 무엇이며, 사용할 때 유의해야 할 점에 대해 설명해 주세요.</li>
<li> 메시지 큐는 단방향이라고 할 수 있나요?</li>
</ul>
</details>

<details>
  <summary><h3>12. Thread Safe 하다는 것은 어떤 의미인가요?</h3></summary>
<ul>
<li> Thread Safe 를 보장하기 위해 어떤 방법을 사용할 수 있나요?</li>
<li> Peterson's Algorithm 이 무엇이며, 한계점에 대해 설명해 주세요.</li>
<li> Race Condition 이 무엇인가요?</li>
</ul>
</details>

<details>
  <summary><h3>13. Thread Pool, Monitor, Fork-Join에 대해 설명해 주세요.</h3></summary>
<ul>
</ul>
</details>

<details>
  <summary><h3>14. 캐시 메모리 및 메모리 계층성에 대해 설명해 주세요.</h3></summary>
<ul>
<li> 캐시 메모리는 어디에 위치해 있나요?</li>
<li> L1, L2 캐시에 대해 설명해 주세요.</li>
<li> 캐시에 올라오는 데이터는 어떻게 관리되나요?</li>
<li> 캐시간의 동기화는 어떻게 이루어지나요?</li>
<li> 캐시 메모리의 Mapping 방식에 대해 설명해 주세요.</li>
<li> 캐시의 지역성에 대해 설명해 주세요.</li>
<li> 캐시의 지역성을 기반으로, 이차원 배열을 가로/세로로 탐색했을 때의 성능 차이에 대해 설명해 주세요.</li>
</ul>
</details>

<details>
  <summary><h3>15.메모리의 연속할당 방식 세 가지를 설명해주세요. (first-fit, best-fit, worst-fit)</h3></summary>
<ul>
<li> worst-fit 은 언제 사용할 수 있을까요?</li>
<li> 성능이 가장 좋은 알고리즘은 무엇일까요?</li>
</ul>
</details>

<details>
  <summary><h3>16. Thrashing 이란 무엇인가요?</h3></summary>
<ul>
<li> Thrashing 발생 시, 어떻게 완화할 수 있을까요?</li>
</ul>
</details>

<details>
  <summary><h3>17. 가상 메모리란 무엇인가요?</h3></summary>
<ul>
<li> 가상 메모리가 가능한 이유가 무엇일까요?</li>
<li> Page Fault가 발생했을 때, 어떻게 처리하는지 설명해 주세요.</li>
<li> 페이지 크기에 대한 Trade-Off를 설명해 주세요.</li>
<li> 페이지 크기가 커지면, 페이지 폴트가 더 많이 발생한다고 할 수 있나요?</li>
</ul>
</details>

<details>
  <summary><h3>18. 세그멘테이션과 페이징의 차이점은 무엇인가요?</h3></summary>
<ul>
<li> 페이지와 프레임의 차이에 대해 설명해 주세요.</li>
<li> 내부 단편화와, 외부 단편화에 대해 설명해 주세요.</li>
<li> 페이지에서 실제 주소를 어떻게 가져올 수 있는지 설명해 주세요.</li>
<li> 어떤 주소공간이 있을 때, 이 공간이 수정 가능한지 확인할 수 있는 방법이 있나요?</li>
<li> 32비트에서, 페이지의 크기가 1kb 이라면 페이지 테이블의 최대 크기는 몇 개일까요?</li>
</ul>
</details>

<details>
  <summary><h3>19. TLB는 무엇인가요?</h3></summary>
<ul>
<li> TLB를 쓰면 왜 빨라지나요?</li>
<li> MMU가 무엇인가요?</li>
<li> TLB와 MMU는 어디에 위치해 있나요?</li>
</ul>
</details>

<details>
  <summary><h3>20. 동기화를 구현하기 위한 하드웨어적인 해결 방법에 대해 설명해 주세요.</h3></summary>
<ul>
<li> volatile 키워드는 어떤 의미가 있나요?</li>
<li> 싱글코어가 아니라 멀티코어라면, 어떻게 동기화가 이뤄질까요?</li>
</ul>
</details>

<details>
  <summary><h3>21. 페이지 교체 알고리즘에 대해 설명해 주세요.</h3></summary>
<ul>
<li> LRU 알고리즘은 어떤 특성을 이용한 알고리즘이라고 할 수 있을까요?</li>
<li> LRU 알고리즘을 구현한다면, 어떻게 구현할 수 있을까요?</li>
</ul>
</details>

<details>
  <summary><h3>22. File Descriptor와, File System에 에 대해 설명해 주세요.</h3></summary>
<ul>
<li> I-Node가 무엇인가요?</li>
</ul>
</details>

<details>
  <summary><h3>23. 동기와 비동기, 블로킹과 논블로킹의 차이에 대해 설명해 주세요.</h3></summary>
<ul>
<li> 그렇다면, 동기이면서 논블로킹이고, 비동기이면서 블로킹인 경우는 의미가 있다고 할 수 있나요?</li>
<li> I/O 멀티플렉싱에 대해 설명해 주세요.</li>
</ul>
</details>
