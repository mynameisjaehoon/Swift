# 가상메모리
- 프로세스 전체가 메모리 내에 올라오지 않더라도 실행이 가능하도록 하는 기법이다.
- 프로그램이 물리메모리보다 커도 된다는 주요 장점이 있다.
## 개발 배경
- 원래는 **실행하려는 코드의 전부를 물리메모리에 존재시켜야 했다.**
- **메모리 용량보다 큰 프로그램은 실행시킬 수 없었다.**
- 여러 프로그램을 동시에 메모리에 올리기에는 용량의 한계, 페이지 교체등의 성능 이슈가 발생했다.
- 별로 사용되지 않는 코드들이 메모리를 차지하는 것을 보고 전체 프로그램이 메모리에 올라와있을 필요는 없다는 것을 알게 되었다.

**프로그램의 일부만 메모리에 올릴 수 있다면?**

- 물리메모리의 크기에 제약받지 않게 된다.
- 더 많은 프로그램을 동시에 실행할 수 있게 된다. `응답시간`은 유지되고, `CPU이용률`과 `처리율`은 높아진다.
- `swap`에 필요한 입출력이 줄어들기 때문에 프로그램이 빠르게 실행된다.

## 가상메모리가 하는 일
- 실제의 물리 메모리 개념과 사용자의 논리메모리 개념을 분리하였다.
- 작은 메모리를 가지고도 큰 `가상 주소공간을` 프로그래머에게 제공할 수 있다.

**가상 주소공간이 뭔가요?**
- 한 프로세스가 메모리에 저장되는 논리적인 모습을 가상메모리에 구현한 공간.
- 직접적으로 필요하지 않은 메모리 공간은 실제 물리메모리에 올리지 않는 방법으로 물리메모리를 절약할 수 잇다.
- 한 프로그램에 100KB가 요구되었고, 실행까지에 필요한 메모리 공간(Stack, Heap, Code, Data)의 합이 40KB라면, 실제 물리메모리에는 40KB만 올라가 있고, 나머지 60KB는 필요시에 물리메모리에 요구하게 된다.

**프로세스간 페이지 공유**

가상메모리는...

- `시스템 라이브러리`가 여러 프로세스들 사이에서 공유될 수 있도록 해준다. 라이브러리에 올라가있는 `물리 메모리 페이지`들은 모든 프로세스에 공유되고 있다.
- 프로세스들이 메모리를 공유하는 것을 가능하게 하고, 프로세스들이 공유메모리를 통해 통신할 수 있다. 각프로세스들은 자신의 주소공간처럼 인식하지만, 실제 물리메모리는 공유되고 있는 것이다.

## **Demand Paging(요구 페이징)**
- 프로그램 시작시에 프로그램 전체를 디스크에서 메모리로 적재하는 대신, 초기에 필요한 것들만 적재하는 전략을 말한다.
- 가상메모리 시스템에서 많이 사용되며, 가상메모리는 대개 페이지로 관리된다.
- 실행과정에서 **필요해질 때** 페이지들이 적재된다. 즉, **한 번도 접근되지 않은 페이지는 물리메모리에 올라가지 않는다.**
- 프로세스 내의 개별 페이지들은 `페이저(pager)`에 의해서 관리된다. 페이저는 프로세스 실행에 실제 필요한 페이지들만 메모리로 읽어 옮으로써, 사용되지 않을 페이지를 가져오는 시간낭비와 메모리낭비를 줄일 수 있다.

## 페이지 교체
- 프로그램 실행시에 모든 항목이 물리메모리에 올라오지 않기 때문에 프로세스의 동작에 필요한 페이지를 요청하는 과정에서 page fault가 발생하게 되면 원하는 페이지를 보조저장장치에서 가져오게 된다.
- 모든 물리메모리가 사용중이라면 페이지 교체가 이루어져야한다.

**기본적으로 물리메모리가 모두 사용중인 상황에서의 흐름은 다음과 같다.**

1. 디스크에서 필요한 페이지의 위치를 찾는다.
2. 페이지의 빈 프레임을 찾는다.
    - `페이지 교체 알고리즘`을 통해 희생될(victim)페이지를 고른다.
    - 희생될 페이지를 디스크에 기록하고, 관련 페이지 테이블을 수정한다.
3. 새롭게 비워진 페이지 테이블 프레임에 새 페이지를 읽어오고, 프레임 테이블을 수정한다.
4. 사용자 프로세스 재시작

**페이지 교체 알고리즘은 다음과 같다.**

- FIFO 페이지 교체
    - 가장 간단한 페이지교체 알고리즘이다.
    - 이름 그대로, 먼저 물리메모리에 들어온 페이지 순서대로 교체시점에 먼저 나가게 된다.
    - 장점
        - 이해하기도 쉽고, 구현하기 쉽다.
    - 단점
        - 오래된 페이지가 항상 불필요한 정보를 가지고 있지는 않다. (ex.전역변수)
        - 처음부터 활발하게 사용되는 페이지를 교체해서 페이지 부재율을 높이는 부작용을 초래할 수 있다.
        - `Balady의 모순`: 페이지를 저아할 수 있는 페이지 프레임의 수를 늘려도 되려 페이지의 부재가 더 많이 발생하는 모순이 존재한다.
- 최적 페이지 교체(Optimal Page Replacement)
    - 앞으로 가장 오랫동안 사용되지 않을 페이지를 찾아서 교체하는 것이다.
    - 알고리즘 중 가장 낮은 페이지 부재율을 보장하지만, 프로세스의 메모리 참조 계획을 미리 파악할 방법이 없기 때문에 구현에 어려움이 있다.
- LRU 페이지 교체(LRU Page Replacement)
    - 가장 오랫동안 사용되지 않은 페이지를 선택하여 교체하는 방법이다.
    - FIFO보다 우수하고, OPT보다는 그렇지 않다.
    - 현실성있는 교체 알고리즘 중에서는 제일 좋다.