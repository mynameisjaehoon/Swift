## 자료구조

<details>
<summary>배열에 대해서 설명해주세요</summary>
<div>
<br>
배열은 메모리에 연속적으로 저장되는 자료구조를 말합니다.

인덱스만 알고 있으면 데이터에 바로 접근할 수 있는 random access가 가능하기 때문에 탐색시간은 상수시간이 걸립니다.

삽입과 삭제 같은경우는 삽입 , 삭제 후에 추가적인 작업을 해주어야 하기 때문에 선형시간이 걸립니다. 삽입을 한 이후에는 데이터를 뒤로 한칸씩 미루어 줘야하고, 삭제후에는 한칸씩 당겨주어야 하기 때문에 최악의 경우 선형시간이 소요됩니다.

</div>
</details>

<details>
<summary>연결리스트에 대해 설명해주세요</summary>
<div>
<br>
연결리스트는 메모리에 연속적으로 저장되어 있는 배열과는 다르게 불규칙적으로 저장될 수 있고 하나의원소가 다음 원소를 가리키고 있는 자료구조입니다. 

탐색에는 연결리스트의 처음부터 차례대로 탐색해나가야 하기 때문에 최악의 경우 선형시간이 소요되는 작업입니다. 삽입과 삭제같은 경우도, 삽입 삭제 작업 자체는 가리키는 다음원소를 변경해주는 것으로 끝나기 때문에 상수시간이 소요되지만 삽입, 삭제하는 원소의 위치로 찾아가기 위해서 결국 선형시간이 소요됩니다.

</div>
</details>

<details>
<summary>스택에 대해서 설명해주세요</summary>
<div>
<br>
스택은 Last In First Out이라는 가장 나중에 들어간 원소가 제일 먼저나오는 선형 자료구조입니다.

</div>
</details>

<details>
<summary>스택이 어디서 쓰이는지 예시를 들어주세요</summary>
<div>
<br>
재귀 알고리즘이나 브라우저의 뒤로가기 기능에서 사용됩니다. iOS에서도 네비게이션 컨트롤러에서 뷰들을 쌓아갈때 스택구조를 사용합니다.

</div>
</details>

<details>
<summary>큐에 대해서 설명해주세요</summary>
<div>
<br>
큐는 First In First Out이라는 가장 먼저들어간 원소가 제일 먼저나오는 선형 자로구조 입니다.

</div>
</details>

<details>
<summary>큐가 어디서 사용되는 알려주세요.</summary>
<div>
<br>
BFS 알고리즘에서도 사용되고, CPU 스케줄링할 때도 이용됩니다.

</div>
</details>

<details>
<summary>트리에 대해서 설명해주세요</summary>
<div>
<br>
트리는 무방향이면서 사이클이 없는 연결그래프를 말합니다. V개의 정점을 가진 트리는 V-1개의 간선을 가지고 두 정점을 연결하는 simple path가 유일하다는 성질이 있습니다.

</div>
</details>

<details>
<summary>이진 트리란 무엇인가요</summary>
<div>
<br>
이진 트리란 각각의 노드가 최대 두개의 자식을 가지는 트리를 말합니다. 

</div>
</details>

<details>
<summary>포화 이진트리가 무엇인가요(Perfect Binary Tree)</summary>
<div>
<br>
모든 레벨이 꽉 찬 이진 트리를 가리켜 포화 이진트리라고 합니다.

</div>
</details>

<details>
<summary>완전 이진트리가 무엇인가요.(Complete Binary Tree)</summary>
<div><br>
위에서 아래로, 왼쪽에서 오른쪽으로 순서대로 차곡차곡 채워진 이진 트리를 완전 이진트리라고 합니다.
</div>
</details>

<details>
<summary>정 이진트리가 무엇인가요.(Full Binary Tree)</summary>
<div>

모든 노드가 0개 혹은 2개의 자식노드만을 갖는 트리를 정 이진 트리라고 합니다.

</div>
</details>

<details>
<summary>이진 탐색 트리에 대해서 설명해주세요</summary>
<div>
<br>
이진 탐색트리는 이진 탐색과 연결리스트를 결합한 자료구조의 일종입니다. 이진 탐색의 효율적인 탐색 능력을 유지하면서 빈번한 자료 입력과 삭제를 가능하게끔 고안된 자료구조입니다.

각 노드의 왼쪽 서브트리에는 해당 노드의 값보다 작은 값을 저장하고, 오른쪽 서브트리에는 큰값을 저장합니다.

왼쪽 서브트리를 읽고, 현재 노드를 읽고, 오른쪽 서브트리를 읽는 중위순회방식을 쓰면 모든 값들을 정렬된 순서대로 읽을 수 있습니다.

</div>
</details>

<details>
<summary>이진탐색트리의 단점은 무엇인가요?</summary>
<div>
<br>
첫번째로는 배열보다 메모리를 많이 사용한다는 점이고,

두번째는 이진탐색트리의 탐색속도가 결국에는 트리의 높이에 해당하는데, 이진 탐색트리가 데이터가 저장되는 순서에 따라서 편향된트리가 될수 있고 노드가 한쪽으로만 계속 추가되면 시간 복잡도가 결국 O(n)이 된다는 점입니다.

</div>
</details>

<details>
<summary>이진탐색트리의 단점을 해결하기 위해서 어떤 방법을 사용하나요?</summary>
<div>
<br>
따라서 트리의 밸런스를 잡아주는 rebancing이라는 과정이 필요합니다. 밸런스트리에는 B-Tree나 레드블랙트리가 있습니다.

</div>
</details>

<details>
<summary>바이너리 힙에 대해서 설명해주세요</summary>
<div>
<br>
최댓값과 최솟값을 찾아내는 연산을 빠르게 하기 위해서 고안된 완전이진트리를 바탕으로한 자료구조입니다. 최대힙과 최소힙 두가지 종류가 있고, 부모와 자식사이의 대소관계를 통해서 자료구조를 유지합니다. 최대 힙이라면 각 노드의 값이 해당 자식의 값보다 크거나 같은 트리를 말합니다.

주로 루트노드의 인덱스를 1로 해서 배열로 구현하게 됩니다.

데이터를 뽑아오기 위해서 루트노드를 제거하게 되고, 루트노드를 제거한 상태에서 다시 힙의 구조를 유지하는 것을 heapify라고 합니다. 이때 시간복잡도가 O(logn)이기 때문에 결국 O(logn)의 시간 복잡도로 최대값 또는 최소값에 접근할 수 있게 됩니다.

</div>
</details>


<details>
<summary>해시테이블에 대해서 설명해주세요</summary>
<div>
<br>
key-value 페어로 데이터를 빠르게 검색할 수 있는 자료구조 입니다.

내부적으로 배열을 사용해서 데이터를 저장하기 때문에 빠른 검색속도를 가집니다. 특정한 값을 검색하는데 고유의 인덱스로 접근하기 때문에 평균적인 케이스에 대해서 시간 복잡도가 O(1)이 됩니다.

Hash Function 이라는 특별한 알고리즘을 이용해서 데이터와 관련된 고유한 값을 만들어낸 뒤 이를 인덱스로 사용합니다.

</div>
</details>

<details>
<summary>그래프에 대해서 설명해주세요</summary>
<div>
<br>
그래프는 정점들과 정점을 연결하는 간선들로 이루어진 자료구조 입니다. 트리또한 그래프이며, 계층 관계를 나타내고 사이클이 없는 그래프를 트리라고 합니다.

</div>
</details>

<details>
<summary>degree란 무엇인가요?</summary>
<div><br>
정점에 연결된 간선의 개수를 degree라고 합니다. 방향그래프에서는 방향성이 존재하기 때문에 들어오는 간선의 개수와 나가는 간선의 개수의 degree가 두개 존재합니다.
</div>
</details>

<details>
<summary>그래프를 구현하는 방법에 대해서 설명해주세요</summary>
<div><br>
그래프를 구현하는 방법에는 인접행렬과 인접 리스트 두가지 방법이 있습니다.

인접 행렬은 정방행렬을 사용하는 방법입니다. 해당하는 위치의 value를 통해서 정점과의 관계를 표현하는 방법입니다. dense graph를 표현할 때 적절한 방법입니다.

인접 리스트는 연결리스트를 이용해서 표현하는 방법입니다. 각 정점간 연결되어있는 정점을 연결리스트로 표현합니다. 공간복잡도는 `O(E+V)`입니다. sparse graph를 표현하는데 적당한 방법입니다.
</div>
</details>

<details>
<summary>DFS 알고리즘이란 무엇인가요?</summary>
<div><br>
그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘입니다. 스택 자료구조를 사용하거나, 재귀로 주로 구현합니다.
</div>
</details>

<details>
<summary>BFS 알고리즘이란 무엇인가요?</summary>
<div><br>
BFS는 그래프에서 가장 가까운 노드부터 우선적으로 탐색하는 알고리즘 입니다. 큐 자료구조를 사용합니다.
</div>
</details>

<details>
<summary>시간복잡도와 공간복잡도에 대해 설명해주세요</summary>
<div><br>
시간복잡도란 코드가 얼마나 빠르게 작동하는지를 의미합니다. 시간복잡도가 커지면 코드는 느려지고, 시간복잡도가 낮아지면 코드는 빨라집니다.

공간복잡도란 코드가 얼마나 많은 메모리를 차지하느냐를 의미합니다. 공간복잡도가 커지면 메모리를 많이 차지하고 공간복잡도가 낮아지면 메모리를 적게 차지합니다. 보통 코드의 효율성에 대해 이야기 할 때는 공간복잡도보다는 시간복잡도에 대해 주로 이야기합니다.

여기서 시간복잡도가 알고리즘의 절대적인 실행시간을 나타내는 것이 아니라 알고리즘을 수행하는데 연산이 몇번 이루어지느냐를 의미합니다.
</div>
</details>

<details>
<summary>Big-O, Big-Theta, Big-Omega 에 대해 설명해 주세요.</summary>
<div><br>
Big-O는 최악의 경우, Big-Omega는 최선의 경우, Big-Theta는 Big-O와 Big-Omega의 공통부분입니다. 최소와 최악의 중간인 평균적인 복잡도 입니다.
</div>
</details>

<details>
<summary>다른 것을 사용하지 않고, Big-O를 사용하는 이유가 있을까요?</summary>
<div><br>
현실에서는 항상 최악의 경우를 생각해야하기 때문에 흔히 Big-O표기법을 많이 사용합니다. 반면, 최선의 경우 Big-Omega는 잘 쓰이지 않습니다. 대부분의 알고리즘이 의도한 특정한 데이터를 삽입해서 최선의 경우가 나오도록 유도할 수 있기 때문입니다. 예를 들어 삽입정렬에서 미리 정렬된 데이터를 넘겨줘서 최선의 경우가 나오게 하도록 유도할 수 있는 경우가 있을 것 같습니다.
</div>
</details>


<details>
<summary>O(1)은 O(N^2) 보다 무조건적으로 빠른가요?</summary>
<div><br>
경우에 따라서 다를 수 있다. 극단적으로 생각해보면, 상수 시간복잡도를 가지는 알고리즘이 1억번의 연산이 필요한 알고리즘이고 N^2의 시간복잡도를 가지는 알고리즘이 4번의 연산이 필요할 수도 있기 때문이다.
</div>
</details>


<details>
<summary>스택과 큐에 대해서 설명해주세요.</summary>
<div><br>
스택과 큐 둘다 선형자료구조 이고 스택은 LIFO으로 가장 마지막에 들어간데이터가 제일 먼저나오는 자료구조이고, 큐는 FIFO으로 가장 먼저들어간 데이터가 제일 먼저 나오는 자료구조 입니다.
</div>
</details>

<details>
<summary>스택 2개로 큐를, 큐 2개로 스택을 만드는 방법과, 그 시간복잡도에 대해 설명해 주세요.</summary>
<div><br>
</div>
</details>

<details>
<summary>시간복잡도를 유지하면서, 배열로 스택과 큐를 구현할 수 있을까요?</summary>
<div><br>
</div>
</details>

<details>
<summary>Prefix, Infix, Postfix 에 대해 설명하고, 이를 스택을 활용해서 계산/하는 방법에 대해 설명해 주세요.</summary>
<div><br>
</div>
</details>

<details>
<summary>Deque는 어떻게 구현할 수 있을까요?</summary>
<div><br>
</div>
</details>